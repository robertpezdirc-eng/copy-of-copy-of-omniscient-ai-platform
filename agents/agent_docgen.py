import os
import json
from typing import List, Dict, Any, Optional

from fastapi import Body
from pydantic import BaseModel, Field

from .common import build_app, get_async_client


app = build_app("omni-docgen")


# ---------- Models ----------


class GenerateSpec(BaseModel):
    title: str = Field("Omni Platform – API Overview")
    targets: List[str] = Field(
        default_factory=lambda: [
            "http://omni-adapt:8000",
            "http://omni-elevator:8000",
            "http://omni-resource-guard:8000",
            "http://omni-forensics:8000",
            "http://omni-rica:8000",
            "http://omni-docgen:8000",
            "http://omni-value:8000",
        ],
        description="Base URLs of services exposing OpenAPI",
    )
    include_repo_overview: bool = True


DOC_OUTPUT_DIR = os.getenv("DOC_OUTPUT_DIR", "./docs/auto")
DOC_INDEX_PATH = os.getenv("DOC_INDEX_PATH", "./docs_index.json")
REPO_PATH = os.getenv("REPO_PATH", ".")


def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)


def update_docs_index(path: str, title: str) -> bool:
    try:
        index = {}
        if os.path.exists(DOC_INDEX_PATH):
            with open(DOC_INDEX_PATH, "r", encoding="utf-8") as fh:
                index = json.load(fh)
        index.setdefault("documents", [])
        # De-duplicate
        existing = {d.get("path"): d for d in index["documents"]}
        existing[path] = {"path": path, "title": title}
        index["documents"] = list(existing.values())
        with open(DOC_INDEX_PATH, "w", encoding="utf-8") as fh:
            json.dump(index, fh, indent=2)
        return True
    except Exception:
        return False


def repo_tree(root: str, max_depth: int = 2, max_entries: int = 200) -> List[Dict[str, Any]]:
    result: List[Dict[str, Any]] = []
    root = os.path.abspath(root)
    for dirpath, dirnames, filenames in os.walk(root):
        rel = os.path.relpath(dirpath, root)
        depth = 0 if rel == "." else rel.count(os.sep) + 1
        if depth > max_depth:
            continue
        entry = {
            "path": rel if rel != "." else "/",
            "dirs": sorted(dirnames)[:50],
            "files": sorted(filenames)[:50],
        }
        result.append(entry)
        if len(result) >= max_entries:
            break
    return result


async def fetch_openapi(base_url: str) -> Optional[Dict[str, Any]]:
    client = get_async_client()
    for path in ["/openapi.json", "/docs/json"]:
        try:
            r = await client.get(base_url.rstrip("/") + path, timeout=15.0)
            if r.status_code == 200 and r.headers.get("content-type", "").startswith("application/json"):
                return r.json()
        except Exception:
            continue
    return None


def render_api_markdown(title: str, apis: Dict[str, Dict[str, Any]], tree: Optional[List[Dict[str, Any]]]) -> str:
    lines: List[str] = []
    lines.append(f"# {title}")
    lines.append("")
    lines.append("Generated by `omni-docgen`. This document aggregates API endpoints discovered across running services.")
    lines.append("")
    if tree:
        lines.append("## Repo Overview")
        for e in tree[:50]:
            lines.append(f"- `{e['path']}`: dirs={len(e['dirs'])}, files={len(e['files'])}")
        lines.append("")

    for base, spec in apis.items():
        lines.append(f"## Service `{base}`")
        if not spec:
            lines.append("- OpenAPI not available")
            lines.append("")
            continue
        paths = spec.get("paths", {})
        for p, ops in paths.items():
            for method, detail in ops.items():
                summ = detail.get("summary") or detail.get("operationId") or ""
                lines.append(f"- `{method.upper()}` `{p}` — {summ}")
        lines.append("")
    return "\n".join(lines)


@app.get("/scan")
async def scan_repo(max_depth: int = 2):
    return {"root": os.path.abspath(REPO_PATH), "tree": repo_tree(REPO_PATH, max_depth=max_depth)}


@app.post("/generate")
async def generate_docs(spec: GenerateSpec = Body(...)):
    apis: Dict[str, Dict[str, Any]] = {}
    for t in spec.targets:
        apis[t] = await fetch_openapi(t)

    tree = repo_tree(REPO_PATH, max_depth=2) if spec.include_repo_overview else None
    md = render_api_markdown(spec.title, apis, tree)

    ensure_dir(DOC_OUTPUT_DIR)
    out_path = os.path.join(DOC_OUTPUT_DIR, "api-overview.md")
    try:
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(md)
        updated = update_docs_index(os.path.relpath(out_path, start="."), spec.title)
    except Exception:
        out_path = None
        updated = False
    return {"path": out_path, "index_updated": updated, "markdown": md}


@app.post("/linkify")
async def linkify(path: str = Body(..., embed=True), title: str = Body(..., embed=True)):
    ok = update_docs_index(path, title)
    return {"linked": ok, "path": path, "title": title}