import os
import json
from typing import List, Dict, Optional, Any

from fastapi import Body
from pydantic import BaseModel, Field

from .common import build_app, get_async_client


app = build_app("omni-value")


# ---------- Models ----------


class MetricSpec(BaseModel):
    name: str = Field(..., description="Logical name, e.g., latency_p95")
    query: Optional[str] = Field(None, description="PromQL to fetch the metric")
    target: Optional[float] = Field(None, description="Desired threshold or SLO")
    weight: float = Field(1.0, description="Relative importance for scoring")


class ValueInput(BaseModel):
    title: str = Field(..., description="Human title of the value package")
    category: str = Field(
        "business",
        description="Category of value: business, reliability, performance, cost, security, adaptability",
    )
    description: Optional[str] = None
    metrics: List[MetricSpec] = Field(default_factory=list)
    extra_signals: Dict[str, float] = Field(default_factory=dict, description="Arbitrary normalized signals [0..1]")


class QualificationResult(BaseModel):
    score: float
    details: Dict[str, Any]


class DocumentResult(BaseModel):
    path: Optional[str]
    markdown: str
    index_updated: bool = False


# ---------- Helpers ----------


PROM_URL = os.getenv("PROMETHEUS_URL", "http://omni-prometheus:9090")
ADAPT_URL = os.getenv("OMNI_ADAPT_URL", "http://omni-adapt:8000")
DOC_OUTPUT_DIR = os.getenv("DOC_OUTPUT_DIR", "./docs/auto")
DOC_INDEX_PATH = os.getenv("DOC_INDEX_PATH", "./docs_index.json")


async def prom_query(query: str) -> Optional[float]:
    if not query:
        return None
    client = get_async_client()
    try:
        r = await client.get(f"{PROM_URL}/api/v1/query", params={"query": query})
        r.raise_for_status()
        data = r.json()
        if data.get("status") == "success":
            result = data.get("data", {}).get("result", [])
            if result:
                # Assume scalar/instant vector first value
                value = float(result[0]["value"][1])
                return value
    except Exception:
        return None
    return None


async def get_adapt_score(default: float = 0.0) -> float:
    client = get_async_client()
    try:
        r = await client.post(
            f"{ADAPT_URL}/evaluate",
            json={
                "scenario": "latency_budget",
                "trials": 1,
                "budget_ms": 500,
            },
            timeout=20.0,
        )
        r.raise_for_status()
        j = r.json()
        return float(j.get("score", default))
    except Exception:
        return default


def clamp01(x: Optional[float]) -> Optional[float]:
    if x is None:
        return None
    return max(0.0, min(1.0, float(x)))


def score_from_target(value: Optional[float], target: Optional[float]) -> Optional[float]:
    if value is None or target is None:
        return None
    # If metric should be below target (latency, errors), higher score if value <= target
    if target >= 0:
        ratio = value / target if target != 0 else 0.0
        # perfect or better => 1.0, degrade linearly down to 0 when 2x target
        s = 1.0 if ratio <= 1.0 else max(0.0, 1.0 - (ratio - 1.0))
        return clamp01(s)
    return None


def render_markdown(title: str, items: List[Dict[str, Any]], total_score: float, category: str, description: Optional[str]) -> str:
    lines = []
    lines.append(f"# {title}")
    if description:
        lines.append("")
        lines.append(description)
    lines.append("")
    lines.append(f"- Category: `{category}`")
    lines.append(f"- Composite score: `{total_score:.3f}`")
    lines.append("")
    lines.append("## Signals and Metrics")
    for it in items:
        name = it.get("name")
        val = it.get("value")
        tgt = it.get("target")
        weight = it.get("weight")
        local_score = it.get("score")
        src = it.get("source")
        lines.append(f"- `{name}` from {src}: value=`{val}`, target=`{tgt}`, weight=`{weight}`, score=`{local_score}`")
    lines.append("")
    lines.append("---")
    lines.append("Generated by `omni-value`.")
    return "\n".join(lines)


def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)


def update_docs_index(path: str, title: str) -> bool:
    try:
        index = {}
        if os.path.exists(DOC_INDEX_PATH):
            with open(DOC_INDEX_PATH, "r", encoding="utf-8") as fh:
                index = json.load(fh)
        index.setdefault("documents", [])
        # De-duplicate
        existing = {d.get("path"): d for d in index["documents"]}
        existing[path] = {"path": path, "title": title}
        index["documents"] = list(existing.values())
        with open(DOC_INDEX_PATH, "w", encoding="utf-8") as fh:
            json.dump(index, fh, indent=2)
        return True
    except Exception:
        return False


# ---------- Endpoints ----------


@app.get("/schemas/values")
async def schema_values():
    return {
        "category_options": [
            "business",
            "reliability",
            "performance",
            "cost",
            "security",
            "adaptability",
        ],
        "metric_spec": MetricSpec.model_json_schema(),
    }


@app.post("/values/qualify", response_model=QualificationResult)
async def qualify_values(payload: ValueInput = Body(...)):
    items: List[Dict[str, Any]] = []
    weights_sum = 0.0
    weighted = 0.0

    # Pull metrics from Prometheus if query provided
    for m in payload.metrics:
        val = await prom_query(m.query) if m.query else None
        sc = score_from_target(val, m.target)
        w = m.weight or 0.0
        if sc is not None:
            weighted += sc * w
            weights_sum += w
        items.append({
            "name": m.name,
            "value": val,
            "target": m.target,
            "weight": w,
            "score": sc,
            "source": "prometheus" if m.query else "user",
        })

    # Extra normalized signals (0..1)
    for k, v in (payload.extra_signals or {}).items():
        v01 = clamp01(v)
        if v01 is not None:
            weighted += v01
            weights_sum += 1.0
        items.append({
            "name": k,
            "value": v,
            "target": 1.0,
            "weight": 1.0,
            "score": v01,
            "source": "signal",
        })

    # Adaptability can be used as a signal if category is adaptability and no metric provided
    if payload.category == "adaptability" and not any(i.get("source") == "prometheus" for i in items):
        adapt_score = await get_adapt_score(0.0)
        weighted += adapt_score
        weights_sum += 1.0
        items.append({
            "name": "adaptability_score",
            "value": adapt_score,
            "target": 1.0,
            "weight": 1.0,
            "score": adapt_score,
            "source": "omni-adapt",
        })

    total = (weighted / weights_sum) if weights_sum > 0 else 0.0
    return QualificationResult(score=total, details={"items": items, "category": payload.category})


@app.post("/values/document", response_model=DocumentResult)
async def document_values(payload: ValueInput = Body(...), auto_link: bool = True):
    # First qualify
    qual = await qualify_values(payload)
    items = qual.details["items"]
    md = render_markdown(payload.title, items, qual.score, payload.category, payload.description)

    # Optionally write to disk
    path = None
    try:
        ensure_dir(DOC_OUTPUT_DIR)
        slug = payload.title.lower().replace(" ", "-")
        path = os.path.join(DOC_OUTPUT_DIR, f"value-{slug}.md")
        with open(path, "w", encoding="utf-8") as f:
            f.write(md)
    except Exception:
        path = None

    index_updated = False
    if auto_link and path:
        rel_path = os.path.relpath(path, start=".")
        index_updated = update_docs_index(rel_path, payload.title)

    return DocumentResult(path=path, markdown=md, index_updated=index_updated)


@app.get("/values/report")
async def values_report(title: str):
    slug = title.lower().replace(" ", "-")
    path = os.path.join(DOC_OUTPUT_DIR, f"value-{slug}.md")
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as f:
            return {"title": title, "path": path, "markdown": f.read()}
    return {"error": "not-found", "hint": path}